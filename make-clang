#!/usr/bin/env python

import os
import sys
import json
import re
import string

def filterArguments(arguments):
  # The command itself is always included.
  filteredArguments = [arguments[0]]
  
  # Append the remaining arguments if they don't have undesirable side effects.
  skipNext = False
  for arg in arguments[1:]:
    if skipNext:
      skipNext = False
    elif arg == '-MD' or (arg.startswith('-W') and ('-MD,' in arg)):
      # Skip because we don't want to generate dependency files.
      pass
    elif arg == '-MF':
      # Skip this argument and the following one because we don't want
      # to generate dependency files.
      skipNext = True
    else:
      filteredArguments.append(arg)
  
  return filteredArguments

def writeLog(logFilename, logEntries):
  with open(logFilename, "a") as f:
    for entry in logEntries:
      dump = json.dumps(entry)
      dump += '\n'
      f.write(dump)

def createLogEntries(arguments):
  # Determine the working directory.
  cwd = os.getcwd()
  
  # Determine the command.
  command = string.join(arguments, ' ')

  # Create regular expression patterns.
  extensionPat = re.compile('\.(c|cc|cpp|C)$')
  headerMap = {
                'c': ['.h'],
                'cc': ['.h', '.hh'],
                'cpp': ['.h', '.hpp'],
                'C': ['.h', '.H']
              }
  
  # Determine the filenames.
  filenames = []
  for arg in arguments[1:]:
    extensionMatch = extensionPat.search(arg)
    if extensionMatch is not None:
      filenames.append(arg)
      extension = extensionMatch.group(1)
      if extension in headerMap:
        filenames.extend([re.sub(extensionPat, headerExt, arg)
                         for headerExt in headerMap[extension]])
  
  if filenames:
    return [{
             'directory': cwd,
             'command': command,
             'file': filename
            } for filename in filenames]
  else:
    #print >>sys.stderr, "create-cdb: Skipping log entry for command [", command, "] because the filename can't be determined."
    return filenames

def doMerge(logFilename, dbFilename):
  # Create hash of the log file for quick access.
  log = {}
  with open(logFilename, "r") as f:
    for line in f:
      try:
        logEntry = json.loads(line)
        log[logEntry['file']] = logEntry
      except:
        print "Skipping line:", line
  
  # Load the existing database.
  try:
    with open(dbFilename, "r") as f:
        db = json.load(f)
  except:
    db = []
  
  # Remove all entries obsoleted by the log.
  db = [dbEntry for dbEntry in db if dbEntry['file'] not in log]
  
  # Add the log entries to the db.
  db.extend(log.values())
  
  # Write the updated db.
  with open(dbFilename, "w") as f:
    json.dump(db, f)

def doLog(logFilename, arguments):
  try:
    logEntries = createLogEntries(arguments)
    if logEntries:
      writeLog(logFilename, logEntries)

    import subprocess
    #print 'Will run',sys.argv[2:]
    proc = subprocess.Popen(arguments)
    ret = proc.wait()
  except:
    import traceback
    exc_type, exc_value, exc_traceback = sys.exc_info()
    traceback.print_exception(exc_type, exc_value, exc_traceback,
                              limit=2, file=sys.stderr)
    raw_input("Press a key")
    
  if ret is None:
    sys.exit(1)
  sys.exit(ret)
  
# Parse commandline arguments
if sys.argv[1] == '--merge':
  logFilename = sys.argv[2]
  dbFilename = sys.argv[3]
  doMerge(logFilename, dbFilename)
elif sys.argv[1] == '--log':
  logFilename = sys.argv[2]
  arguments = filterArguments(sys.argv[3:])
  doLog(logFilename, arguments)
else:
  logFilename = sys.argv[1]
  arguments = filterArguments(sys.argv[2:])
  doLog(logFilename, arguments)
